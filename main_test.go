package main

import (
	"testing"
)

func TestH(t *testing.T) {
    var tests = []struct {
        input uint8
        output uint8
    }{
        {0xa2, 0x9b},
    }

    for _, test := range tests {
        if got := H(test.input); got != test.output {
            t.Errorf("H(%x) is %x, not %x", test.input, test.output, got)
        }
    }
}

func TestG(t *testing.T) {
    var tests = []struct{
        u uint32
        r uint32
        result uint32
    }{
        {
            0xb194bac8,
            5,
            0x14a43d1f,
        },
    }
    for _, test := range tests {
        if got := G(test.r, test.u); got != test.result {
            t.Errorf("G(%d, %x) is %x, not %x", test.r, test.u, test.result, got)
        }
    }
}

func TestFe(t *testing.T) {
    var tests = []struct{
        block block
        key key
        result block
    }{
        {
            block{0xB194BAC8, 0x0A08F53B, 0x366D008E, 0x584A5DE4},
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            block{0x69CCA1C9, 0x3557C9E3, 0xD66BC3E0, 0xFA88FA6E},
        },
        {
            block{0x0DC53006, 0x00CAB840, 0xB38448E5, 0xE993F421},
            key{0x92BD9B1C, 0xE5D14101, 0x5445FBC9, 0x5E4D0EF2, 0x682080AA, 0x227D642F, 0x2687F934, 0x90405511},
            block{0xE12BDC1A, 0xE28257EC, 0x703FCCF0, 0x95EE8DF1},
        },
    }
    for _, test := range tests {
        if got := Fe(test.block, test.key); got != test.result {
            t.Errorf("Fe(%x, %x) is %x, not %x", test.block, test.key, test.result, got)
        }
    }
}

func TestFd(t *testing.T) {
    var tests = []struct{
        block block
        key key
        result block
    }{
        {
            block{0xE12BDC1A, 0xE28257EC, 0x703FCCF0, 0x95EE8DF1},
            key{0x92BD9B1C, 0xE5D14101, 0x5445FBC9, 0x5E4D0EF2, 0x682080AA, 0x227D642F, 0x2687F934, 0x90405511},
            block{0x0DC53006, 0x00CAB840, 0xB38448E5, 0xE993F421},
        },
        {
            block{0x69CCA1C9, 0x3557C9E3, 0xD66BC3E0, 0xFA88FA6E},
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            block{0xB194BAC8, 0x0A08F53B, 0x366D008E, 0x584A5DE4},
        },
    }
    for _, test := range tests {
        if got := Fd(test.block, test.key); got != test.result {
            t.Errorf("Fd(%x, %x) is %x, not %x", test.block, test.key, test.result, got)
        }
    }
}

func equal(x, y []block) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}

func TestECBe(t *testing.T) {
    var tests = []struct{
        blocks []block
        key key
        result []block
    }{
        {
            []block{
                {0xB194BAC8, 0x0A08F53B, 0x366D008E, 0x584A5DE4},
                {0x8504FA9D, 0x1BB6C7AC, 0x252E72C2, 0x02FDCE0D},
                {0x5BE3D612, 0x17B96181, 0xFE6786AD, 0x716B890B},
            },
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            []block{
                {0x69CCA1C9, 0x3557C9E3, 0xD66BC3E0, 0xFA88FA6E},
                {0x5F23102E, 0xF1097107, 0x75017F73, 0x806DA9DC},
                {0x46FB2ED2, 0xCE771F26, 0xDCB5E5D1, 0x569F9AB0},
            },
        },
        {
            []block{
                {0x0DC53006, 0x00CAB840, 0xB38448E5, 0xE993F421},
                {0xE55A239F, 0x2AB5C5D5, 0xFDB6E81B, 0x40938E2A},
                {0x54120CA3, 0xE6E19C7A, 0xD750FC35, 0x31DAEAB7},
            },
            key{0x92BD9B1C, 0xE5D14101, 0x5445FBC9, 0x5E4D0EF2, 0x682080AA, 0x227D642F, 0x2687F934, 0x90405511},
            []block{
                {0xE12BDC1A, 0xE28257EC, 0x703FCCF0, 0x95EE8DF1},
                {0xC1AB7638, 0x9FE678CA, 0xF7C6F860, 0xD5BB9C4F},
                {0xF33C657B, 0x637C306A, 0xDD4EA779, 0x9EB23D31},
            },
        },
    }
    for _, test := range tests {
        if got := ECBe(test.blocks, test.key); !equal(got, test.result) {
            t.Errorf("ECBe(%x, %x) is %x, not %x", test.blocks, test.key, test.result, got)
        }
    }
}

func TestECBd(t *testing.T) {
    var tests = []struct{
        blocks []block
        key key
        result []block
    }{
        {
            []block{
                {0x69CCA1C9, 0x3557C9E3, 0xD66BC3E0, 0xFA88FA6E},
                {0x5F23102E, 0xF1097107, 0x75017F73, 0x806DA9DC},
                {0x46FB2ED2, 0xCE771F26, 0xDCB5E5D1, 0x569F9AB0},
            },
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            []block{
                {0xB194BAC8, 0x0A08F53B, 0x366D008E, 0x584A5DE4},
                {0x8504FA9D, 0x1BB6C7AC, 0x252E72C2, 0x02FDCE0D},
                {0x5BE3D612, 0x17B96181, 0xFE6786AD, 0x716B890B},
            },
        },
        {
            []block{
                {0xE12BDC1A, 0xE28257EC, 0x703FCCF0, 0x95EE8DF1},
                {0xC1AB7638, 0x9FE678CA, 0xF7C6F860, 0xD5BB9C4F},
                {0xF33C657B, 0x637C306A, 0xDD4EA779, 0x9EB23D31},
            },
            key{0x92BD9B1C, 0xE5D14101, 0x5445FBC9, 0x5E4D0EF2, 0x682080AA, 0x227D642F, 0x2687F934, 0x90405511},
            []block{
                {0x0DC53006, 0x00CAB840, 0xB38448E5, 0xE993F421},
                {0xE55A239F, 0x2AB5C5D5, 0xFDB6E81B, 0x40938E2A},
                {0x54120CA3, 0xE6E19C7A, 0xD750FC35, 0x31DAEAB7},
            },
        },
    }
    for _, test := range tests {
        if got := ECBd(test.blocks, test.key); !equal(got, test.result) {
            t.Errorf("ECBd(%x, %x) is %x, not %x", test.blocks, test.key, test.result, got)
        }
    }
}

func TestCBCe(t *testing.T) {
    var tests = []struct{
        blocks []block
        key key
        iv block
        result []block
    }{
        {
            []block{
                {0xB194BAC8, 0x0A08F53B, 0x366D008E, 0x584A5DE4},
                {0x8504FA9D, 0x1BB6C7AC, 0x252E72C2, 0x02FDCE0D},
                {0x5BE3D612, 0x17B96181, 0xFE6786AD, 0x716B890B},
            },
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            block{0xBE329713, 0x43FC9A48, 0xA02A885F, 0x194B09A1},
            []block{
                {0x10116EFA, 0xE6AD58EE, 0x14852E11, 0xDA1B8A74},
                {0x5CF2480E, 0x8D03F1C1, 0x9492E53E, 0xD3A70F60},
                {0x657C1EE8, 0xC0E0AE5B, 0x58388BF8, 0xA68E3309},
            },
        },
        {
            []block{
                {0x730894D6, 0x158E17CC, 0x1600185A, 0x8F411CAB},
                {0x0471FF85, 0xC8379239, 0x8D8924EB, 0xD57D03DB},
                {0x95B97A9B, 0x7907E4B0, 0x20960455, 0xE46176F8},
            },
            key{0x92BD9B1C, 0xE5D14101, 0x5445FBC9, 0x5E4D0EF2, 0x682080AA, 0x227D642F, 0x2687F934, 0x90405511},
            block{0x7ECDA4D0, 0x1544AF8C, 0xA58450BF, 0x66D2E88A},
            []block{
                {0xE12BDC1A, 0xE28257EC, 0x703FCCF0, 0x95EE8DF1},
                {0xC1AB7638, 0x9FE678CA, 0xF7C6F860, 0xD5BB9C4F},
                {0xF33C657B, 0x637C306A, 0xDD4EA779, 0x9EB23D31},
            },
        },
    }
    for _, test := range tests {
        // In 2007 edition of the standard Y0, X0 are equal to F_theta(S), but in 2011 it is changed to plain S. Testcases are from the 2011 edition
        if got := CBCe(test.blocks, test.key, Fd(test.iv, test.key)); !equal(got, test.result) {
            t.Errorf("CBCe(%x, %x, %x) is %x, not %x", test.blocks, test.key, test.iv, test.result, got)
        }
    }
}

func TestCBCd(t *testing.T) {
    var tests = []struct{
        blocks []block
        key key
        iv block
        result []block
    }{
        {
            []block{
                {0x10116EFA, 0xE6AD58EE, 0x14852E11, 0xDA1B8A74},
                {0x5CF2480E, 0x8D03F1C1, 0x9492E53E, 0xD3A70F60},
                {0x657C1EE8, 0xC0E0AE5B, 0x58388BF8, 0xA68E3309},
            },
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            block{0xBE329713, 0x43FC9A48, 0xA02A885F, 0x194B09A1},
            []block{
                {0xB194BAC8, 0x0A08F53B, 0x366D008E, 0x584A5DE4},
                {0x8504FA9D, 0x1BB6C7AC, 0x252E72C2, 0x02FDCE0D},
                {0x5BE3D612, 0x17B96181, 0xFE6786AD, 0x716B890B},
            },
        },
        {
            []block{
                {0xE12BDC1A, 0xE28257EC, 0x703FCCF0, 0x95EE8DF1},
                {0xC1AB7638, 0x9FE678CA, 0xF7C6F860, 0xD5BB9C4F},
                {0xF33C657B, 0x637C306A, 0xDD4EA779, 0x9EB23D31},
            },
            key{0x92BD9B1C, 0xE5D14101, 0x5445FBC9, 0x5E4D0EF2, 0x682080AA, 0x227D642F, 0x2687F934, 0x90405511},
            block{0x7ECDA4D0, 0x1544AF8C, 0xA58450BF, 0x66D2E88A},
            []block{
                {0x730894D6, 0x158E17CC, 0x1600185A, 0x8F411CAB},
                {0x0471FF85, 0xC8379239, 0x8D8924EB, 0xD57D03DB},
                {0x95B97A9B, 0x7907E4B0, 0x20960455, 0xE46176F8},
            },
        },
    }
    for _, test := range tests {
        // Fd() is used because of the later change in the standard
        if got := CBCd(test.blocks, test.key, Fd(test.iv, test.key)); !equal(got, test.result) {
            t.Errorf("CBCd(%x, %x, %x) is %x, not %x", test.blocks, test.key, test.iv, test.result, got)
        }
    }
}

func equalBytes(x, y []byte) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}

func TestCFBe(t *testing.T) {
    var tests = []struct{
        bytes []byte
        key key
        iv block
        result []byte
    }{
        {
            []byte{
                0xB1, 0x94, 0xBA, 0xC8, 0x0A, 0x08, 0xF5, 0x3B, 0x36, 0x6D, 0x00, 0x8E, 0x58, 0x4A, 0x5D, 0xE4,
                0x85, 0x04, 0xFA, 0x9D, 0x1B, 0xB6, 0xC7, 0xAC, 0x25, 0x2E, 0x72, 0xC2, 0x02, 0xFD, 0xCE, 0x0D,
                0x5B, 0xE3, 0xD6, 0x12, 0x17, 0xB9, 0x61, 0x81, 0xFE, 0x67, 0x86, 0xAD, 0x71, 0x6B, 0x89, 0x0B,
            },
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            block{0xBE329713, 0x43FC9A48, 0xA02A885F, 0x194B09A1},
            []byte {
                0xC3, 0x1E, 0x49, 0x0A, 0x90, 0xEF, 0xA3, 0x74, 0x62, 0x6C, 0xC9, 0x9E, 0x4B, 0x7B, 0x85, 0x40,
                0xA6, 0xE4, 0x86, 0x85, 0x46, 0x4A, 0x5A, 0x06, 0x84, 0x9C, 0x9C, 0xA7, 0x69, 0xA1, 0xB0, 0xAE,
                0x55, 0xC2, 0xCC, 0x59, 0x39, 0x30, 0x3E, 0xC8, 0x32, 0xDD, 0x2F, 0xE1, 0x6C, 0x8E, 0x5A, 0x1B,
            },
        },
        {
            []byte{
                0xFA, 0x9D, 0x10, 0x7A, 0x86, 0xF3, 0x75, 0xEE, 0x65, 0xCD, 0x1D, 0xB8, 0x81, 0x22, 0x4B, 0xD0,
                0x16, 0xAF, 0xF8, 0x14, 0x93, 0x8E, 0xD3, 0x9B, 0x33, 0x61, 0xAB, 0xB0, 0xBF, 0x08, 0x51, 0xB6,
                0x52, 0x24, 0x4E, 0xB0, 0x68, 0x42, 0xDD, 0x4C, 0x94, 0xAA, 0x45, 0x00, 0x77, 0x4E, 0x40, 0xBB,
            },
            key{0x92BD9B1C, 0xE5D14101, 0x5445FBC9, 0x5E4D0EF2, 0x682080AA, 0x227D642F, 0x2687F934, 0x90405511},
            block{0x7ECDA4D0, 0x1544AF8C, 0xA58450BF, 0x66D2E88A},
            []byte{
                0xE1, 0x2B, 0xDC, 0x1A, 0xE2, 0x82, 0x57, 0xEC, 0x70, 0x3F, 0xCC, 0xF0, 0x95, 0xEE, 0x8D, 0xF1,
                0xC1, 0xAB, 0x76, 0x38, 0x9F, 0xE6, 0x78, 0xCA, 0xF7, 0xC6, 0xF8, 0x60, 0xD5, 0xBB, 0x9C, 0x4F,
                0xF3, 0x3C, 0x65, 0x7B, 0x63, 0x7C, 0x30, 0x6A, 0xDD, 0x4E, 0xA7, 0x79, 0x9E, 0xB2, 0x3D, 0x31,
            },
        },
    }
    for _, test := range tests {
        if got := CFBe(test.bytes, test.key, test.iv); !equalBytes(got, test.result) {
            t.Errorf("CFBe(%x, %x, %x) is %x, not %x", test.bytes, test.key, test.iv, test.result, got)
        }
    }
}

func TestCFBd(t *testing.T) {
    var tests = []struct{
        bytes []byte
        key key
        iv block
        result []byte
    }{
        {
            []byte {
                0xC3, 0x1E, 0x49, 0x0A, 0x90, 0xEF, 0xA3, 0x74, 0x62, 0x6C, 0xC9, 0x9E, 0x4B, 0x7B, 0x85, 0x40,
                0xA6, 0xE4, 0x86, 0x85, 0x46, 0x4A, 0x5A, 0x06, 0x84, 0x9C, 0x9C, 0xA7, 0x69, 0xA1, 0xB0, 0xAE,
                0x55, 0xC2, 0xCC, 0x59, 0x39, 0x30, 0x3E, 0xC8, 0x32, 0xDD, 0x2F, 0xE1, 0x6C, 0x8E, 0x5A, 0x1B,
            },
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            block{0xBE329713, 0x43FC9A48, 0xA02A885F, 0x194B09A1},
            []byte{
                0xB1, 0x94, 0xBA, 0xC8, 0x0A, 0x08, 0xF5, 0x3B, 0x36, 0x6D, 0x00, 0x8E, 0x58, 0x4A, 0x5D, 0xE4,
                0x85, 0x04, 0xFA, 0x9D, 0x1B, 0xB6, 0xC7, 0xAC, 0x25, 0x2E, 0x72, 0xC2, 0x02, 0xFD, 0xCE, 0x0D,
                0x5B, 0xE3, 0xD6, 0x12, 0x17, 0xB9, 0x61, 0x81, 0xFE, 0x67, 0x86, 0xAD, 0x71, 0x6B, 0x89, 0x0B,
            },
        },
        {
            []byte{
                0xE1, 0x2B, 0xDC, 0x1A, 0xE2, 0x82, 0x57, 0xEC, 0x70, 0x3F, 0xCC, 0xF0, 0x95, 0xEE, 0x8D, 0xF1,
                0xC1, 0xAB, 0x76, 0x38, 0x9F, 0xE6, 0x78, 0xCA, 0xF7, 0xC6, 0xF8, 0x60, 0xD5, 0xBB, 0x9C, 0x4F,
                0xF3, 0x3C, 0x65, 0x7B, 0x63, 0x7C, 0x30, 0x6A, 0xDD, 0x4E, 0xA7, 0x79, 0x9E, 0xB2, 0x3D, 0x31,
            },
            key{0x92BD9B1C, 0xE5D14101, 0x5445FBC9, 0x5E4D0EF2, 0x682080AA, 0x227D642F, 0x2687F934, 0x90405511},
            block{0x7ECDA4D0, 0x1544AF8C, 0xA58450BF, 0x66D2E88A},
            []byte{
                0xFA, 0x9D, 0x10, 0x7A, 0x86, 0xF3, 0x75, 0xEE, 0x65, 0xCD, 0x1D, 0xB8, 0x81, 0x22, 0x4B, 0xD0,
                0x16, 0xAF, 0xF8, 0x14, 0x93, 0x8E, 0xD3, 0x9B, 0x33, 0x61, 0xAB, 0xB0, 0xBF, 0x08, 0x51, 0xB6,
                0x52, 0x24, 0x4E, 0xB0, 0x68, 0x42, 0xDD, 0x4C, 0x94, 0xAA, 0x45, 0x00, 0x77, 0x4E, 0x40, 0xBB,
            },
        },
    }
    for _, test := range tests {
        if got := CFBd(test.bytes, test.key, test.iv); !equalBytes(got, test.result) {
            t.Errorf("CFBd(%x, %x, %x) is %x, not %x", test.bytes, test.key, test.iv, test.result, got)
        }
    }
}

func TestCTR(t *testing.T) {
    var tests = []struct{
        bytes []byte
        key key
        iv block
        result []byte
    }{
        {
            []byte{
                0xB1, 0x94, 0xBA, 0xC8, 0x0A, 0x08, 0xF5, 0x3B, 0x36, 0x6D, 0x00, 0x8E, 0x58, 0x4A, 0x5D, 0xE4,
                0x85, 0x04, 0xFA, 0x9D, 0x1B, 0xB6, 0xC7, 0xAC, 0x25, 0x2E, 0x72, 0xC2, 0x02, 0xFD, 0xCE, 0x0D,
                0x5B, 0xE3, 0xD6, 0x12, 0x17, 0xB9, 0x61, 0x81, 0xFE, 0x67, 0x86, 0xAD, 0x71, 0x6B, 0x89, 0x0B,
            },
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            block{0xBE329713, 0x43FC9A48, 0xA02A885F, 0x194B09A1},
            []byte {
                0x52, 0xC9, 0xAF, 0x96, 0xFF, 0x50, 0xF6, 0x44, 0x35, 0xFC, 0x43, 0xDE, 0xF5, 0x6B, 0xD7, 0x97,
                0xD5, 0xB5, 0xB1, 0xFF, 0x79, 0xFB, 0x41, 0x25, 0x7A, 0xB9, 0xCD, 0xF6, 0xE6, 0x3E, 0x81, 0xF8,
                0xF0, 0x03, 0x41, 0x47, 0x3E, 0xAE, 0x40, 0x98, 0x33, 0x62, 0x2D, 0xE0, 0x52, 0x13, 0x77, 0x3A,
            },
        },
        {
            []byte {
                0x52, 0xC9, 0xAF, 0x96, 0xFF, 0x50, 0xF6, 0x44, 0x35, 0xFC, 0x43, 0xDE, 0xF5, 0x6B, 0xD7, 0x97,
                0xD5, 0xB5, 0xB1, 0xFF, 0x79, 0xFB, 0x41, 0x25, 0x7A, 0xB9, 0xCD, 0xF6, 0xE6, 0x3E, 0x81, 0xF8,
                0xF0, 0x03, 0x41, 0x47, 0x3E, 0xAE, 0x40, 0x98, 0x33, 0x62, 0x2D, 0xE0, 0x52, 0x13, 0x77, 0x3A,
            },
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            block{0xBE329713, 0x43FC9A48, 0xA02A885F, 0x194B09A1},
            []byte{
                0xB1, 0x94, 0xBA, 0xC8, 0x0A, 0x08, 0xF5, 0x3B, 0x36, 0x6D, 0x00, 0x8E, 0x58, 0x4A, 0x5D, 0xE4,
                0x85, 0x04, 0xFA, 0x9D, 0x1B, 0xB6, 0xC7, 0xAC, 0x25, 0x2E, 0x72, 0xC2, 0x02, 0xFD, 0xCE, 0x0D,
                0x5B, 0xE3, 0xD6, 0x12, 0x17, 0xB9, 0x61, 0x81, 0xFE, 0x67, 0x86, 0xAD, 0x71, 0x6B, 0x89, 0x0B,
            },
        },
    }
    for _, test := range tests {
        if got := CTR(test.bytes, test.key, test.iv); !equalBytes(got, test.result) {
            t.Errorf("CTR(%x, %x, %x) is %x, not %x", test.bytes, test.key, test.iv, test.result, got)
        }
    }
}

func TestIncrement(t *testing.T) {
    var tests = []struct{
        iv block
        result block
    }{
        {
            block{0xFEFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},
            block{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},
        },
        {
            block{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},
            block{0, 0, 0, 0},
        },
        {
            block{0xFFFFFFFF, 0, 0, 0},
            block{0, 0x01000000, 0, 0},
        },
    }
    for _, test := range tests {
        test.iv.Increment()
        if got := test.iv; got != test.result {
            t.Errorf("%x.Increment() is %x, not %x", test.iv, test.result, got)
        }
    }
}

func TestMAC(t *testing.T) {
    var tests = []struct{
        bytes []byte
        key key
        result uint64
    }{
        {
            []byte{0xB1, 0x94, 0xBA, 0xC8, 0x0A, 0x08, 0xF5, 0x3B, 0x36, 0x6D, 0x00, 0x8E, 0x58},
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            uint64(0x7260DA60138F96C9),
        },
        {
            []byte{
                0xB1, 0x94, 0xBA, 0xC8, 0x0A, 0x08, 0xF5, 0x3B, 0x36, 0x6D, 0x00, 0x8E, 0x58, 0x4A, 0x5D, 0xE4,
                0x85, 0x04, 0xFA, 0x9D, 0x1B, 0xB6, 0xC7, 0xAC, 0x25, 0x2E, 0x72, 0xC2, 0x02, 0xFD, 0xCE, 0x0D,
                0x5B, 0xE3, 0xD6, 0x12, 0x17, 0xB9, 0x61, 0x81, 0xFE, 0x67, 0x86, 0xAD, 0x71, 0x6B, 0x89, 0x0B,
            },
            key{0xE9DEE72C, 0x8F0C0FA6, 0x2DDB49F4, 0x6F739647, 0x06075316, 0xED247A37, 0x39CBA383, 0x03A98BF6},
            uint64(0x2DAB59771B4B16D0),
        },
    }
    for _, test := range tests {
        if got := MAC(test.bytes, test.key); got != test.result {
            t.Errorf("MAC(%x, %x) is %x, not %x", test.bytes, test.key, test.result, got)
        }
    }
}

func TestHash(t *testing.T) {
    var tests = []struct{
        bytes []byte
        result hash
    }{
        {
            []byte{0xB1, 0x94, 0xBA, 0xC8, 0x0A, 0x08, 0xF5, 0x3B, 0x36, 0x6D, 0x00, 0x8E, 0x58},
            hash{0xABEF9725, 0xD4C5A835, 0x97A367D1, 0x4494CC25, 0x42F20F65, 0x9DDFECC9, 0x61A3EC55, 0x0CBA8C75},
        },
        {
            []byte{
                0xB1, 0x94, 0xBA, 0xC8, 0x0A, 0x08, 0xF5, 0x3B, 0x36, 0x6D, 0x00, 0x8E, 0x58, 0x4A, 0x5D, 0xE4,
                0x85, 0x04, 0xFA, 0x9D, 0x1B, 0xB6, 0xC7, 0xAC, 0x25, 0x2E, 0x72, 0xC2, 0x02, 0xFD, 0xCE, 0x0D,
            },
            hash{0x749E4C36, 0x53AECE5E, 0x48DB4761, 0x227742EB, 0x6DBE13F4, 0xA80F7BEF, 0xF1A9CF8D, 0x10EE7786},
        },
        {
            []byte{
                0xB1, 0x94, 0xBA, 0xC8, 0x0A, 0x08, 0xF5, 0x3B, 0x36, 0x6D, 0x00, 0x8E, 0x58, 0x4A, 0x5D, 0xE4,
                0x85, 0x04, 0xFA, 0x9D, 0x1B, 0xB6, 0xC7, 0xAC, 0x25, 0x2E, 0x72, 0xC2, 0x02, 0xFD, 0xCE, 0x0D,
                0x5B, 0xE3, 0xD6, 0x12, 0x17, 0xB9, 0x61, 0x81, 0xFE, 0x67, 0x86, 0xAD, 0x71, 0x6B, 0x89, 0x0B,
            },
            hash{0x9D02EE44, 0x6FB6A29F, 0xE5C982D4, 0xB13AF9D3, 0xE90861BC, 0x4CEF27CF, 0x306BFB0B, 0x174A154A},
        },
    }
    for _, test := range tests {
        if got := Hash(test.bytes); got != test.result {
            t.Errorf("Hash(%x) is %x, not %x", test.bytes, test.result, got)
        }
    }
}
